# 面试时如何介绍设计模式？
	这个是什么样的设计模式，作用是什么，解决了什么样的问题，具体角色划分，项目中怎么使用的，优缺点又是什么？

	与其它模式的区别，类同，结合使用也可以介绍



# 设计模式原则:

> 1、开闭原则（Open Close Principle）
```
	对扩展开放，对修改关闭。
    简单理解就是，程序需要扩展的时候，不去修改原有的逻辑，而达到一种热插拔的效果。

 	要做到开闭原则，我们就必须使用面向接口，抽象编程了。
```
> 2、里氏替换原则
```
	任何基类可以出现的地方，子类一定可以出现。是继承复用的基石。
	鼓励在代码中使用基类，而不是直接使用子类
	里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范
```
> 3、依赖倒转原则
```
    这个原则是开闭原则的基础。具体内容：针对接口编程，依赖于抽象而不依赖于具体
```
> 4、接口隔离原则
```
		这个原则的意思是：使用多个隔离的接口，比使用单个接口要好
		它还有另外一个意思是：降低类之间的耦合度
```
> 5、迪米特法则，又称最少知道原则
```
    一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立
	尽可能的和其它类降低耦合，不要有关系
	拒绝想客户端提供不需要的功能
```
> 6、合成复用原则
```
  尽量使用合成/聚合的方式，而不是使用继承
```
> 7、单一职责原则
```
   避免一个类担任多职责，做多种事情
```


```
小结:
	设计模式就是设计出便于升级和维护的软件。要达到这些就要代码之间 降低依赖，降低耦合
```

# 1.什么设计模式
	在开发过程中我们会遇到很多不同的业务场景，一种业务的实现方式有很多，我们需要使用一种合适的方式来解决这个问题。  要求 方便代码维护，可扩展性高。 这种合适方式就是合适模式。
	简单说，设计模式，就是最简单，高效的解决问题的方案

# 2.什么是 GOF（四人帮，全拼 Gang of Four）？
这个是由国外的四人合著的一个书。他们所提出的设计模式主要是基于以下的面向对象设计原则：
以接口编程而不是实现；
优先使用对象组合而不是继承；


# 3.设计模式的类型

	> 创建型设计模式：
		创建型设计模式的共性， 隐藏对象的创建过程，不是用new直接创建出一个对象。 这使得程序在选择使用那些实例时更灵活。
		创建型设计模式分:
				原型模式（Prototype），单例模式（Singleton），工厂模式(factory),建造者模式(builder)

	> 结构型设计模式:
		这些设计模式关注类和对象的组合。 使用继承把类、接口等组合在一起，形成一套更强大的结构，
		继承的概念 被用来 组合接口 和 定义组合对象 获得新功能的方式
		其实也为了解耦或者功能更全。

		分：
			适配器模式（Adapter），桥接模式（Bridge）,代理模式(Proxy),门面模式（Facade）,享元模式（FlyWeight）,组合模式(Composite)，装饰模式（decorator）,过滤器(Filter)

	> 行为型设计模式:
		这些设计模式关注的是，对象间的通信
		责任链模式（Chain of Responsibility Pattern），命令模式（Command Pattern），解释器模式（Interpreter Pattern），迭代器模式（Iterator Pattern），
		中介者模式（Mediator Pattern），备忘录模式（Memento Pattern），观察者模式（Observer Pattern），状态模式（State Pattern），空对象模式（Null Object Pattern），
		策略模式（Strategy Pattern），模板模式（Template Pattern），访问者模式（Visitor Pattern）

	> J2EE 模式：
		这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的
		MVC 模式（MVC Pattern），业务代表模式（Business Delegate Pattern），组合实体模式（Composite Entity Pattern），数据访问对象模式（Data Access Object Pattern）
		前端控制器模式（Front Controller Pattern），拦截过滤器模式（Intercepting Filter Pattern），服务定位器模式（Service Locator Pattern），传输对象模式（Transfer Object Pattern）




# 创建型设计模式
```
	隐藏对象的创建过程，不是用new直接创建出一个对象,这使得程序在选择使用那些实例时更灵活

	原型模式（Prototype），单例模式（Singleton），工厂模式(factory),建造者模式(builder)
```

## 工厂方法模式:
	1.定义。工厂方法模式是创建型模式中的一种，对客户端隐藏创建对象的过程， 提供一个抽象接口，客户端通过这个抽象接口选择具体的抽象类，创建出想要的对象。
	至于这个对象是如何创建出来的，客户端不需要关心。

	2.应用实例 ：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，。如果想买宝马就从宝马4s点去提取，如果想买奔驰就去奔驰4s店提取。
	车是我们想要的产品，具体什么的品牌车就去什么品牌下的4s店买车。
	4s店 是车厂的一种抽象， 宝马4s，奔驰4s是车厂的具体是实现。 从4s店提取出来的车就是具体产品。

	缺点:
		每新增一个品牌车就需要开一个4s店工厂，这样操作会使的系统类成倍增加（新增一个品牌车同时需要新增这个品牌车的工厂）。


	常见业务场景：
		 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方
		 2、


## 抽象工厂模式：
	1.定义。
		它是提供的是创建出一个产品族，不仅仅是单一的产品。
		前面介绍的工厂方法模式。  这种模式只能产生车这类的产品，  我时候想要买保险这类产品怎么办。


	2.实例应用 还是上面买车的场景，我们要买车，同时也要买保险。
		抽象对象车（Car）. 抽象对象保险（insure）。具体的车类产品 ： 宝马（BMWCar）、奔驰(BenCar).  具体的保险产品:太平洋车险(TaiPingYanInsure)、中国人寿保险(RenShouInsure)

		抽象工厂 BuyCartFactroy { Cart buyCar(); Insure buyInsure();} 具体工厂. BuyBMWCarFactory implement BuyCartFactory {}

	3.缺点:  每增加一个产品 所有的工厂都要同步增加

	常见业务场景：
		1、QQ 换皮肤，一整套一起换



 ## 单例模式：
 	1.定义： 整个系统生命周期里，这个类就只会被实例化一次。


 ## 原型模式：
 	1.定义：  给定一个对象，使用克隆技术将这个对象重新复制一份。

 ## 创造者模式:
 	1.定义:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建出不同的表示。

 	角色:
 		抽象产品类:(Product) ，
 		抽象建造者：规范产品的组建，一般由子类实现
 		具体建造者: 实现抽象建造者定义的具体规范，并返回一个已经组建好的对象。例子BenBuilder,BMWBuilder
 		导演者: Director , 导演者定义好产品类创建的具体步骤，然后Builder 开始构建。生成出具体的产品


 	2.还是上面的车的示例。
 		车的零部件： 车轮，车窗，发动机，车架

 		抽象产品车（Car）,具体创建出来的是不同品牌的车。

 		导演者: 根据提供的不同的零部件产出的产品不同。 比如 提供3个轮，柴油机，车架，车窗。可以生成出3轮车。 提供4个轮，宝马发动机，宝马车架，车窗。生成出宝马车


 		2、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。

 	3.解决问题

 		主要解决在软件系统中，有时候面临着“一个复杂的对象”的创建工作，其通常由各个部分的子对象一起的构成；
 		由于需求的变化，这个复杂的对象的各个部分经常面临着剧烈的变化，但是它们组合在一起的算法却相对稳定。

 	4.使用场景 ：
 		 1.相同的方法，不同的顺序，产生不同结果，可以采用构建者模式
 		 2.多个零部件或者组件，都可以装配到一个对象中，但是产生的运行结果不同。
 		 3.产品非常复杂，或者产品类中的调用顺序不同产生了不同的效果。
 		 4.



 	优点：
 		1、建造者独立，易扩展。
 	 	2、便于控制细节风险。
 	缺点：
 		1、产品必须有共同点，范围有限制。
 		2、如内部变化复杂，会有很多的建造类。



# 结构型设计模式
```
	关注类和对象的组合。
	继承的概念 被用来 组合接口 和 定义组合对象 获得新功能的方式

	适配器模式（Adapter），桥接模式（Bridge）,代理模式(Proxy),门面模式（Facade）,享元模式（FlyWeight）,组合模式(Composite)，装饰模式（decorator)
```

## 适配器模式:
	定义: 作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能
	将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
	JDK中InputStreamReader 就是适配器模式，为InputStream ,BufferReader  两个接口提供了桥梁

	场景： 耳机转接口。  现在的手机耳机孔都部分都是Type-c口子。我们原来买的耳机都说圆孔，如果想要老的耳机还能用就需要有一个圆孔耳机与Type-c空结合的 转接口线。

	转接口线就是Adpater 也叫Wrapper, NewPhone--->TypeCEarPhone,RoundEarPhone--->EarPhone


	角色: 目标角色(EarPhone),源角色(NewPhone),适配器(Adpater)


	public interface EarPhone(){ void listenMusic(String type)}
	public class RoundEarPhone  {
		 public void listenMusic() {
		 	println("round ear phone")
		 }

	}
	public class Adpater implement EarPhone {
		RoundEarPhone roundEarPhone
		public Adpater (RoundEarPhone roundEarPhone) {
			this.roundEarPhone = roundEarPhone
		}
		void listenMusic(String type) {
			if(type.equals("typec"))
			roundEarPhone.listenMusic();
		}
	}

	public class NewTypeCEarPhone implement EarPhone {
		EarPhone earPhone;
		public Phone(EarPhone earPhone) {
			this.earPhone = earPhone;
		}
		void listenMusic(String type) {
			if(type.equals("typec")) {
				System.out.println("paly music")
			}else {
				earPhone.listenMusic();
			}
		}
	}

	public static void main(String[] args) {
		NewPhone phone = new NewPhone(new Adpater(new RoundEarPhone())) ;
		phone.listenMusic();
	}



	优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好
	缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类






## 桥接模式：
	定义：将抽象部分与实现部分解藕，使它们都可以独立的变化.
	抽象角色的部分功能 是由 实现化角色完成的

	意图:对变化的封装，尽量把可能变化的因素封装到最小的逻辑单元中，避免风险扩散，设计系统是若发现类的继承N层次时可以考虑桥接模式。

	主要解决：主要是解决用继承会造成类爆炸问题，扩展起来不灵活。


	优点：
		1、抽象和实现的分离。
				解决用继承会造成类爆炸问题，扩展起来不灵活。
		2、优秀的扩展能力。
				示例中，可以随意增加具体的抽象 也可以随意增加具体的实现。 不会带来类的爆炸性增长
		3、实现细节对客户透明。

	缺点：
		桥接模式的引入会增加系统的理解与设计难度，
		由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

	示例： 手机按外形可以分翻盖手机，全屏手机，折叠机，按品牌可以分Vivo,小米，华为。 每个手机都可以打电话。 设计这个类结构

	传统的层级: Phone |-----小米----| ---翻盖
			         			  | ---全屏
			         			  | ---折叠

			  Phone |-----Vivo----| ---翻盖
			         			  | ---全屏
			         			  | ---折叠

	 按传统设计这个会带来很多类，并且每增加一个品牌就会多很多的 手机特性， 如果所有的手机都增加一个特性， 那多少的品牌就要增加多少个特性


	模型可以分: ，Brand, Vivo ,XiaoMi,HuaWei    FlipPhone,FullScreenPhone,FolderPhone---Phone (功能Call)
	示例中抽象部分是Phone系列，实现部分是Brand系列。  在抽象部分依赖实现部分这样就可以桥接起来了

	Abstraction<>--------------> implementor
	继承 							继承
	^ 								 ^
	|								 |
	|								 |
	|								 |
	RefinedAbstraction				ConcreteImplementor

	角色:
		Abstraction :抽象化角色，它的主要职责是定义出该抽象的行为，同时保存一个对实现化角色引用，该角色一般是抽象类
		Implementor: 实现化角色，它是接口或者抽象类，定义角色必须的行为或者属性
		RefinedAbstration: 修正抽象化角色，它引用实现化角色对抽象化角色进行修正
		ConcreteImplementor:具体实现角色。

	桥接模式使用了类间的聚合，继承，覆写等常用功能，



## 组合模式:
	定义：
		树状结构专用模式
		又称部分-整体模式，是用于把一组相似的对象当作一个单一的对象。
		组合模式依据树形结构来组合对象，用来表示部分以及整体层次，
		它创建了对象组的树形结构

	意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

	如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。

	关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

	案例:
	使用设计模式打印出公司的组织架构及相关人员信息.
	Deparment 部门信息。 Employee 员工信息    JollyModel

	角色:
		抽象构件角色(Component) : 它给参加组合的对象规定一个接口，这个角色给出共有的接口及默认行为
		树叶构件角色（Leaf）: 它代表参加组合的树叶对象。树叶下没有下级对象
		树枝构件（Composite）: 它代表参加组合的有子对象的对象，并给出树枝构件对象的行为

	类图:
		Component:interface <-------------|
		实现 				实现.  		  |
		| 					|			  |
		|					|			  |
		|					|			  |
		Leaf 			Composite <>------|


## 装饰器模式: 又名Wapper 包装模型
	定义:
		可以对客户端透明的方式，扩展对象的功能，是继承的一种替代方案

	意图:动态的给一个对象添加不同的功能
	案例：
		去奶茶店买奶茶， 可以选择不同品种奶茶，和添加不同的料。 比如加冰块，加椰果，加糖...

	当我们想给一个类中某个方法添加一些额外的功能时，一种方式是我们修改这个方法，但这种违法了开闭原则，容易影响其它的功能使用。
	第二种方式是使用类继承扩展这个类的功能，但是使用类继承方式使得代码耦合度很高，并且扩展性不够灵活，比如通过类继承覆盖这个方法，然后添加C功能，如果后期需求变化，我想在增加D功能，这个时候
	如果不改变子类就只能继续派生出一个子类扩展，非常不灵活，代码耦合度也很高。这时如果想撤销某个功能怎么办，没法撤。

	第三种方式使用复合/组合的方式：代理模式，装饰模式
	代理模式和装饰模式上是非常接近的。
	代理模式与装饰模式的区别：
		装饰模式 意图是对被装饰对象的原有功能的增强；
		代理模式 强调的是代理类 对被代理对象的控制。 代理上可以做方法增强，这种增强的本质是对目标对象的拦截和过滤。比如游戏收费。。。
		这类计算，是代理类的额外功能，可以用代理 实现这个额外功能的接口来扩展
		 举个例子：
			1.装饰模式：对被装饰的对象增加额外的职责，满足里氏代换原则（子类可以代替父类）
			如：杯子生产线，杯子必须可以装水，在生产线上可以给杯子涂颜色，加杯盖，但要保证杯子可以装水。
			2.代理模式：对被代理的对象提供访问控制。
			如：客户订购商品，可以直接从厂家订购，也可以从网上商城订购，网上商城是厂家的代理，从网上商城订购商品，商城可以对商品进行控制，不交钱不给商品，人不在不给商品，也可以赠送你额外的礼品，代金券。

	角色：
		抽象类/接口 （TeaMilk）： 定义我们最原始，最核心的功能的接口
		具体实现类 (CooskinMilkTea,Coffee):	核心功能的具体实现类。
		抽象装饰类（TeaDecorator）: 抽象装饰类，继承或者实现TeaMilk,  引入TakMilk 抽象
		具体装饰类 (SugaTeaDecorator,MilkTeaDecorator): 具体的增加功能类。



## 享元模式:
	定义：利用共享技术有效的支持大量细粒度的对象。 比如Integer,Byte, String(放在常量池中)
	目的：重复利用对象
	spring ioc 容器。 ioc容器管理了很多的Bean实例，数据库连接池。。

	两个核心要求： 共享对象 和 细粒度对象
	内部状态： 是对象可共享出来的信息，存储在享元对象内部且不会随环境变化。
	外部状态： 找到共享对象的唯一标示，随环境改变而改变，不可以共享的状态。

	角色：
		抽象享元角色： 简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或者实现。
		具体享元角色：实现抽象角色定义的业务，需要保证外部状态（唯一标示）不会被改变 。 不然就找不到对应的共享池中的对象了
		享元工厂： 构件一个池子容器，同时提供冲池中获取对象的方法


	优点:
		如果系统又大量类似的对象，可以节省大量的内存和CPU资源

	缺点：提升了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具体固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。

	1.什么样的对象需要共享呢？
		a):系统中存在大量相似的对象
		b):细粒度的对象都具备较接近的外表状态（Key）,而内部状态与环境无关，也就是说对象没有特定身份
		c):需要缓冲池的场景


## 门面模式/外观模式（facade）：
	门面模式 也是一种常用的封装模式，提供一个统一的门面对象，来应对外界与系统内部的交互，至于系统部与多少子系统交互，怎么交互的交互的外部不用关心。但是外部（调用方）能够得到它想要的结果。
	意图：为子系统中的一组接口提供一个一致的高层接口，隐藏系统内部的复杂性，使得系统更容易使用。
	比如：客户端调用服务端，只需要调用某一个接口，提供必要的信息，就能使用这个功能

	角色：
		门面角色：客户端调用这个角色的方法，此角色知晓子系统的所有功能和责任。一般情况，门面会将客户端的请求都分派到对应的子系统中去，此类没有实际的业务逻辑，只是一个委托。
		子系统角色 :子系统并不知道门面的存在，它可以是一个或者多个子系统的集合。

	优点：
		1.减少系统的相互依赖 。 客户端不用和子系统之间交互，不需要知道复杂的逻辑。 耦合度降低，
		2.提高了灵活性。   以后就算子系统变动，也只有门面类调整就好了
	缺点：
		不符合开闭原则， 如果以后子系统发生变化， 只能在门面方法中做调整的。


## 代理模式：
	代理模式也称为委托模式，为其它对象提供一个代理，以控制对这个对象的访问。
	状态模式，策略模式，访问者模式本质上是在更特殊的场合采用了委托模式

	场景：点外卖。 店铺委托外面员送外卖，用户收到外卖。    店铺是被代理对象， 外卖员代理类， 抽象是送买卖给客户。  店铺老板不自己送，交给别人送。

	角色定义：
		被代理对象的抽象类：
		被代理对象的具体实现类：
		代理类 ： 实现了 抽象类，  聚合了抽象类，
	优点：
		职责清晰
		高扩展性

## 动态代理：
	动态代理在实现阶段不用关心代理对象，而在运行阶段才制定代理一个对象。

	使用： 定一个动态代理类，实现InvocationHandler接口， 实现invoke方法 .    在invoke方法中通过method.invoke(this.obj,arg)完成对证实对象的代理动作。



# 行为型设计模式
```
	关注对象之间的通信

	责任链模式（Chain of Responsibility Pattern），命令模式（Command Pattern），解释器模式（Interpreter Pattern），迭代器模式（Iterator Pattern），
		中介者模式（Mediator Pattern），备忘录模式（Memento Pattern），观察者模式（Observer Pattern），状态模式（State Pattern），空对象模式（Null Object Pattern），
		策略模式（Strategy Pattern），模板模式（Template Pattern），访问者模式（Visitor Pattern）
```

## 责任链模式：
	使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象链接成了一条链。并沿着这条链传递该请求，直到有对象处理他位置。
	责任链的重点是在“链”上，有一条链去处理相似的请求，在链中决定谁来处理这个请求，并返回相应的结果。

	责任链模式屏蔽了请求处理过程，请求者只需要将请求传递给第一个责任人，任务最终会返回结果（结果可能是空）。

	责任链模式一般和 模版方法模式，命令模式，合成模式结合使用

	1.当责任链模式中的对象链属于一个较大的结构时，这个较大的结构可能是按照合成模式的要求来构造。
	//2.责任链模式使一个特定的请求接受对象对请求或者命令的执行变得不确定。。而命令模式 是一个特定的对象对一个命令的执行变得明显和确定。

	角色分配:
		抽象处理者：
			定义三个职责：
			1.定义一个请求处理方法,规范子类处理请求的操作，唯一对外开放的方法，一般用final修饰。
			2.设置下一个请求处理者，
			3.定义每个处理者能处理什么类型的请求，具体的处理逻辑方法
		具体处理者:

	案例1: 击鼓传花儿游戏， 从第一个人开始依次往后传花球，当敲鼓声停的时候，花球在谁手里，谁站起来唱歌。
		这个案例中，传递花球 是一个 请求，  传递给不同人代表不同的处理该请求的具体对象。   鼓声停，得花球人。分别代表 可以处理该请求的信号 和 处理该请求的对象。

	案例2：
		员工请假，根据请假理由，请假时间不同的领导作出批示
		请假流程： 员工填写请假单,发起请假申请---->项目组领导A审批---->部门领导审批---->小于等于2天的HR审批结束，超过两天的CTO审批，超过10天的CEO审批-----> HR结束


		员工A ---

	不使用模式的方式：
			梳理：定一个员工请假接口，定义多个子类实现该接口（多级领导），作出动作，查看理由，同意/不同意
			不用模式，使用if..else..根据时间作出判断。 缺点：职责划分不清晰，代码臃肿，耦合过重

	优点:
		将请求与处理类分开，不耦合在一起；
		请求者不用知道具体是谁处理的请求；
		处理者也不用知道请求的全貌
	缺点：
		1.因为是链式的处理方式，一个请求很可能需要流转到链尾才会被处理， 如果链路很长可能有性能问题;
		2.不利调试，



## 命令模式：
	定义：
		命令模式属于行为模式中的一种，又称为行动模式或者交易模式。
		命令模式把一个请求或者一个操作封装到一个对象中（对命令的封装），把发出命令的责任和执行命令的责任分开，委派给不同的对象。
		每一个命令都是一个操作，请求的一方发出命令要求执行一操作，接受请求的一方执行操作；

	角色：
		Receiver 接收者:  具体干活的角色，命令传达到这个角色去做什么事情。
		Invoker 调用者： 接收命令并触发命令。 聚合了命令的抽象类
		Command 命令:	聚合执行请求的Receiver。当客户端发出名气后（调用命令的execute），命令调用Receiver的具体业务方法，处理客户端请求

	伪代码：
		public interface Receiver{ void doBiz(); }
		public abstract class ConcreteReceiver implement Receiver{ public void doBiz(){} }
		public abstract class Command {
			protected Receiver receiver;
			public Command(Receiver receiver) {this.receiver=receiver}
			abstract void execute();
		}
		public class Command1 extends Command{
			public Command1(){
				super(new ConcreteReceiver())
			}
			public void execute(){
				super.receiver.doBiz();
			}
		}
		public class Invoker {
			private Command command;
			public Invoker(Command command) {
				this.command=command;
			}
			public void action(){
				command.execute();
			}
		}


	场景：假设现在有电视、电脑、电灯等家电，现在需要你做个遥控器控制所有家电的开关，要求做到每个按钮对应的功能供用户个性化，对于新买入家电要有非常强的扩展性


	优点:
		1.类间解耦
			调用者(invoker) 与 执行者(Receiver) 之间没有任何的依赖，调用者直接使用command抽象类，执行command的execute方法就可以了。
		2.Command和Receiver都方便扩展
			扩展不同的Command就可以扩展不同的业务，而Invoker和Client层不产生严重的代码耦合。
		3.可与多种模式结合使用。比如责任链模式，模版方法模式

	缺点:
		如果有N个命令，那么就将有N 个子类。类膨胀会比较厉害


## 命令模式 + 责任链模式



## 解释器模式
	很少用到的一种模式，
	它是一种 按照规定语法进行解析的 方案。

	缺点:
		引起效率，性能，维护等问题
	注意事项：尽量不要在重要模块使用解释器模式，否则维护是一个很大的问题，在项目中可以使用脚本语言来代替 解释器模式，弥补Java语言编译型语言的不足。

## 迭代器模式
	为迭代容器中的元素而生的模式，
	专为容器和容器跌代而使用的模式，在JDK的集合类中都实现了Iterator接口，每个容器内部实现自己的迭代的方式。
	用于顺序访问集合对象的元素，不需要知道集合对象的底层。

	属于没落的模式，很少有人在重新开发这种模式

	意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示

## 中介者模式 (Mediator Pattern)

	定义：
		中介者又称为调停者,
		用一个中介者对象，封装类与类之间的调用关系，中介者使得类与类之间的调用关系不在显示的相互作用，从而使得类与类的耦合度降低
	角色 ：
		抽象的中介者 （Mediator）：
				定义统一的接口，用于各个同事类之间的通信
		具体的中介者 (Concrete Mediator)：
				处理各个同事者之间的调用关系，因此它必须依赖各个同事类角色
		同事角色 colleague：
				每个同事角色都知道中介者角色，而且与其它同事角色交互时，都是通过中介角色协作。


	优点：
		减少了对象之间的依赖关系，有1对多，变成了1对一，同事类之间只依赖中介者，对象与对象的依赖关系解耦合了；

	缺点:
		中介者会膨胀的很大，而且封装的逻辑会比较复杂，同事类越多复杂度就越大

		中介者是一个很好的封装模式，但也是容易被乱用的模式。 一个对象依赖几个对象是再正常不过的事情。纯理论的按这个模式来封装对象的依赖关系是非常危险的，容易造成中介者膨胀。




	什么时候使用中介者模式:
	 	N个对象相互依赖 N>2;
	 	多个对象有依赖，且依赖的关系可能发生变化；
	 	当多个对象见的依赖关系成为一个网状结构时，一定要考虑用中介者，将依赖关系解耦

	 中介者实际应用：
	 	MVC框架； Controller就是一个中介者，他将M层与V层隔离开，协调M与V协同工作
	 	机场调度中心： 机场调度中心就是一个调停者，调度着每个飞机的降落和起飞
	 	房屋中介：中介担当着调停者，如果没有中介，租房人就只能自己一个个小区找房源，在联系房东，在签订合同等等一系列事情。有中介我们就剩事情很多，只需要跟着中介看房，签合同，交钱就可以了

	 最佳实践：
	 	一般不需要抽象的中介者，因为中介者很少有共性，有一个具体的中介者就可以了。除非你的业务超级复杂中介者需要扩展多个子类；


	思考，中介者与门面模式的不同。
		门面模式主要是解决 客户端调用的统一接口问题，不需要自己来一个个对接很多子系统或子业务；
		中介者模式，解决的事，子系统与子系统或者子业务之间的相互调用关系解耦合；
		他们的作用对象不同，




## 备忘录模式
	定义：
		保存一个对象的某个状态，以便在适当的时候恢复对象
		官方定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以把该对象恢复到原先保存的状态

	角色：
		Originator 发起人角色: 需要记录状态快照的对象。记录当前时刻的内部状态，提供 记录和恢复方法
		Mementor 备忘录角色: 备份发起人角色的状态。
		Caretaker 备忘录管理员: 对备忘录角色管理，提供存储、获取、删除备忘录 方法

	优点：
	 	1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。
	 	2、实现了信息的封装，使得用户不需要关心状态的保存细节

	缺点：
		消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

	注意事项：
		1.生命周期， 有存储就需要有回收，避免不必要的垃圾
		2.性能， 备忘的频率， 如果需要备忘很多的对象，就不太合适。 1：控制不了需要备忘的数量，比如在for中备忘，2:浪费太多的资源，

	备忘录模式的扩展：
		1.通过 clone 复制整个对象进行备忘，适合简单对象
		2. 多状态备忘录，Caretaker 需要结合 集合 使用
		3.多对象，多状态备忘， Caretaker 使用HashMap存储

## 观察者模式
	定义：
		观察者模式又称发布订阅模式。
		定义对象间一对多的依赖关系，当这个对象的状态发生变化需要通知依赖的对象，我状态变化了。


	角色：
		Observable/Subject 抽象的被观察者:  一般是个抽象类，需要提供，注册观察者，通知观察者，移除观察者方法
		Observer 抽象观察者: 定义观察者收到消息后，对收到的消息进行处理的接口

		ConcreteObservable : 具体的被观察者，实现自己的业务逻辑，并确定那些业务变动，需要通知观察者

		ConcreateObserver : 具体的观察者, 实现Observer 中的update更新接口


	优点:
		1.观察者与被观察者之间是抽象耦合；
			如此设计不论观察者还是被观察者都很容易扩展，在Java JDK中已经实现了最顶层的抽象，Observer,Obserable
		2.订阅发布方式，每个类的职责单一	，通过发布订阅方式，把消息扩散出去

	缺点:
		需要考虑开发效率与运行效率。
			1.一个被观察者会有多个观察者，开发和调试比较麻烦
			2.JDK源码中消息是按倒序方式一个个通知下去的，如果，其中一个消息堵塞了会造成其它后续消息等待



## 状态模式
	定义：
		当一个对象内在状态改变时，允许其改变行为，这个类看起来像改变了其类。
		程序运行过程中，对象内的状态存在不同状态，并且在发生者相互切换。这时就可以考虑用状态模式。

		状态模式顾名思义，就是多个状态不停的切换过程中，不同的状态实现不同的方法


	优点：
		1.避免了过多的switch..case 或者if..else 语句使用，避免了程序的复杂性，提高了程序的可维护性。
		2.很好的体现了开闭原则和单一职责原则。每一个状态就是一个子类，



## 策略模式
	定义:
		定义一组算法 ，将每个算法都封装起来，并且使它们之间可以互换。

		”一组算法“ 三种不同策略
		"封装算法" 封装类Context

	角色:
		抽象算法 Strategy： 策略，算法家族的抽象，一般是接口。 定义算法或者策略 必须具备的方法和属性。
		具体算法：
		封装类Context:  上下文角色，起 承上启下的作用，屏蔽了高层对策略、算法的直接访问。封装可能存在的变化

	优点:
		1.策略可以自由切换，通过策略封装类进行访问具体的策略
		2.避免了多重条件判断
		3.扩展性良好
	缺点：
		1.策略类可能会不断的增多。 每个策略就是一个类，策略越多，策略类就越多
		2.策略类必须对外暴露。上层模块必须知道有哪些策略


## 模板模式

	定义： 抽象类中，定义好一个操作的规范，而将具体实现延迟到子类中。使得子类在不改变规范的情况实现某些特定步骤。

	为了防止恶意破坏，一般模版方法上都会加上final修饰，不允许子类覆盖。
	模版方法中定义的基本方法，尽量用protected修饰，符合迪米特法制。不需要暴露的属性，方法尽量不设置protected类型。
	实现类若非必要，不应扩大父类的访问权限

	public abstract class A {
		protected abstract void do1();
		protected abstract void do2();
		public final void doSomeThing{
			do1();
			do2();
		}
	}
	public class B extends A {
		protected void do1(){//....}
		protected void do2(){//....}
	}

	优点:
		1.封装不变部分，扩展可变部分。
			把认为不变的部分封装到抽象类中，使用子类去实现需要变化的部分。
		2.提取公共代码，便于维护
		3.行为由父类控制，子类实现

	缺点:
		1. 若父类公共部分改动，影响所有子类的实现


## 访问者模式












